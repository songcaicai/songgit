/*
 * Copyright (c) 2006-2021, RT-Thread Development Team
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Change Logs:
 * Date           Author       Notes
 * 2021-05-24     18782       the first version
 */
//日志标签定义
#define LOG_TAG     "TcpClient"
#include <COMMON_HEADER/common_header.h>

#define BUFF_SIZE (1024)
#define MAX_VAL(A, B) ((A) > (B) ? (A) : (B))
#define STRCMP(a, R, b) (strcmp((a), (b)) R 0)
#define RX_CB_HANDLE(_buff, _len, _client_number)  \
    do                             \
    {                              \
        if (thiz->rx)              \
            thiz->rx(_buff, _len, _client_number); \
    } while (0)

#define PRINTF_TEST(_buff, _len, _tag) \
    do                                 \
    {                                  \
        _buff[_len] = '\0';            \
        LOG_D(":%s\n", _buff);         \
    } while (0)

#define EXCEPTION_HANDLE(_bytes, _tag, _info_a, _info_b, _client_number)                  \
    do                                                                    \
    {                                                                     \
        if(_bytes < 0 || _bytes == 0) LOG_D("%s\n",_tag);            \
        if(_bytes < 0 || _bytes == 0) LOG_D("%s\n",_info_a);                  \
        if (_bytes < 0)                                                   \
        {                                                                 \
            LOG_D("return: %d\n", _bytes);                                \
            goto exit;                                                    \
        }                                                                 \
        if (_bytes == 0)                                                  \
        {                                                                 \
            if (STRCMP(_info_b, ==, "warning"))                           \
                LOG_D("return: %d\n", _bytes);                            \
            else                                                          \
            {                                                             \
                LOG_D("return: %d\n", _bytes);                            \
                goto exit;                                                \
            }                                                             \
        }                                                                 \
    } while (0)


 //RX_CB_HANDLE("TCP disconnect", strlen("TCP disconnect"), _client_number);
#define EXIT_HANDLE(_buff)                                            \
    do                                                                \
    {                                                                 \
        if (STRCMP(_buff, ==, "exit"))                                \
        {                                                             \
            LOG_D("exit handle, receive [exit], exit thread\n");   \
            LOG_D("exit handle, user clean up resources pleas\n"); \
            goto exit;                                                \
        }                                                             \
    } while (0)

/*tcp客户端结构体*/
struct rt_tcpclient
{
    uint8_t tcpclient_number;
    int sock_fd;
    int pipe_read_fd;
    int pipe_write_fd;
    char pipe_name[8];
    rx_cb_t rx;
};

/*数据透传tcp客户端1*/
struct rt_tcpclient *tcpclient1 = RT_NULL;
/*数据透传tcp客户端2*/
struct rt_tcpclient *tcpclient2 = RT_NULL;
/*私有协议tcp客户端2*/
struct rt_tcpclient *tcpclient3 = RT_NULL;

/* 消息队列控制块 */
static struct rt_messagequeue register_rx_mq;
/* 注册包接收消息结构定义*/
struct register_rx_msg
{
    uint8_t client_number;
};
static char register_msg_pool[256];

#define TC_TCPCLIENT_CLOSE (1 << 0)
#define TC_EXIT_THREAD (1 << 1)
#define TC_SWITCH_TX (1 << 2)
#define TC_SWITCH_RX (1 << 3)
#define STRCMP(a, R, b) (strcmp((a), (b)) R 0)
#define REGISTER_EVENT1 (1 << 11)
#define REGISTER_EVENT2 (1 << 11)

static void rt_tc_test_deinit(rt_tcpclient_t *thiz);

static rt_tcpclient_t *tcpclient_create(uint8_t tcpcilent_number);
static rt_int32_t tcpclient_destory(rt_tcpclient_t *thiz);
static rt_int32_t socket_init(rt_tcpclient_t *thiz, const char *url, rt_uint32_t port);
static rt_int32_t socket_deinit(rt_tcpclient_t *thiz);
static rt_int32_t pipe_init(rt_tcpclient_t *thiz);
static rt_int32_t pipe_deinit(rt_tcpclient_t *thiz);
static void select_handle(rt_tcpclient_t *thiz, char *pipe_buff, char *sock_buff);
static rt_int32_t tcpclient_thread_init(rt_tcpclient_t *thiz);
static void tcpclient_thread_entry(void *param);
static int connect_status_print(int argc, char **argv);
rt_int32_t rt_tcpclient_attach_rx_cb(rt_tcpclient_t *thiz, rx_cb_t cb);
static void rt_tc_rx_cb(void *buff, rt_size_t len,uint8_t client_number);


/* register package send when data server connect success */
void register_messagequeue_init(void)
{
    /* 初始化消息队列 */
    rt_mq_init(&register_rx_mq, "register_rx_mq",
               register_msg_pool,                 /* 存放消息的缓冲区 */
               sizeof(struct register_rx_msg),    /* 一条消息的最大长度 */
               sizeof(register_msg_pool),         /* 存放消息的缓冲区大小 */
               RT_IPC_FLAG_FIFO);        /* 如果有多个线程等待，按照先来先得到的方法分配消息 */
}

int register_message_send(uint8_t client_number)
{
    struct register_rx_msg msg;
    rt_err_t result;
    msg.client_number = client_number;

    result = rt_mq_send(&register_rx_mq, &msg, sizeof(msg));
    if ( result == -RT_EFULL)
    {
        /* 消息队列满 */
        LOG_E("message queue full!");
    }
    return result;
}

/**
 * @brief tcp客户端创建函数
 * @author shijiabao
 * @date 2021.08.20
 * @param tcpcilent_number：tcp客户端的编号
 * @return rt_tcpclient_t：tcp客户端结构体
 *         RT_NULL：失败
 */
/*创建tcp客户端，返回值为tcp客户端结构体*/
static rt_tcpclient_t *tcpclient_create(uint8_t tcpclient_number)
{
    rt_tcpclient_t *thiz = RT_NULL;

    thiz = rt_malloc(sizeof(rt_tcpclient_t));
    if (thiz == RT_NULL)
    {
        LOG_D("tcpclient%d alloc, malloc error\n",tcpclient_number);
        return RT_NULL;
    }

    thiz->tcpclient_number = tcpclient_number;
    thiz->sock_fd = -1;
    thiz->pipe_read_fd = -1;
    thiz->pipe_write_fd = -1;
    memset(thiz->pipe_name, 0, sizeof(thiz->pipe_name));
    thiz->rx = RT_NULL;

    return thiz;
}

/**
 * @brief tcp客户端摧毁函数
 * @author shijiabao
 * @date 2021.08.20
 * @param rt_tcpclient_t：tcp客户端结构体
 * @return 0：成功
 *        -1：失败
 */
static rt_int32_t tcpclient_destory(rt_tcpclient_t *thiz)
{
    int res = 0;

    if (thiz == RT_NULL)
    {
        LOG_D("tcpclient %d del, param is NULL, delete failed\n", thiz->tcpclient_number);
        return -1;
    }

    if (thiz->sock_fd != -1)
        socket_deinit(thiz);

    if (thiz->pipe_read_fd != -1)
    {
        res = close(thiz->pipe_read_fd);
        RT_ASSERT(res == 0);
        thiz->pipe_read_fd = -1;
    }

    if (thiz->pipe_write_fd != -1)
    {
        res = close(thiz->pipe_write_fd);
        RT_ASSERT(res == 0);
        thiz->pipe_write_fd = -1;
    }

    LOG_D("tcpclient %d del, delete succeed\n",thiz->tcpclient_number);

    free(thiz);
    thiz = RT_NULL;

    return 0;
}


/**
 * @brief tcp客户端的socket套接字初始化，以及网络连接
 * @author shijiabao
 * @date 2021.08.20
 * @param rt_tcpclient_t：tcp客户端结构体
 *        url：IP地址
 *        port：端口
 * @return 0：成功
 *        -1：失败
 */
static rt_int32_t socket_init(rt_tcpclient_t *thiz, const char *url, rt_uint32_t port)
{
    struct sockaddr_in dst_addr;
    struct hostent *hostname;
    rt_int32_t res = 0;
    rt_int8_t count = 4;
    char buf[50];
    uint8_t length = 0;

    if (thiz == RT_NULL)
        return -1;

    thiz->sock_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (thiz->sock_fd == -1)
    {
        LOG_D("tcpclient%d socket init,socket create failed\n",thiz->tcpclient_number);
        return -1;
    }

    LOG_D("tcpclient%d socket:%d\n",thiz->tcpclient_number,thiz->sock_fd);

    hostname = gethostbyname(url);

    dst_addr.sin_family = AF_INET;
    dst_addr.sin_port = htons(port);
    dst_addr.sin_addr = *((struct in_addr *)hostname->h_addr);
    memset(&(dst_addr.sin_zero), 0, sizeof(dst_addr.sin_zero));

    while(count--)
    {
        res = connect(thiz->sock_fd, (struct sockaddr *)&dst_addr, sizeof(struct sockaddr));
        if(res == -1)
        {
            return -1;
        }else {
            /* 发送注册包 */
            if(thiz->tcpclient_number == 1)
            {
                send(thiz->sock_fd, device_parm.configure.register_packet1, sizeof(device_parm.configure.register_packet1), 0);
            }else if(thiz->tcpclient_number == 2)
            {
                send(thiz->sock_fd, device_parm.configure.register_packet2, sizeof(device_parm.configure.register_packet2), 0);
            }
            else if(thiz->tcpclient_number == 3)
            {
                length = data_packet_device_registration_instruction(buf,device_parm.configure.serial_number,strlen(device_parm.configure.serial_number));
                send(thiz->sock_fd, buf, length, 0);
            }
            else {
                ;
            }
            break;
        }
    }

    LOG_D("tcpclient %d socket init,TCP connected succeed",thiz->tcpclient_number);
    return 0;
}

/**
 * @brief tcp客户端的socket套接字关闭
 * @author shijiabao
 * @date 2021.08.20
 * @param rt_tcpclient_t：tcp客户端结构体
 * @return 0：成功
 *        -1：失败
 */
static rt_int32_t socket_deinit(rt_tcpclient_t *thiz)
{
    int res = 0;

    if (thiz == RT_NULL)
    {
        LOG_D("tcpclient%d socket deinit,param is NULL, socket deinit failed\n",thiz->tcpclient_number);
        return -1;
    }

    res = closesocket(thiz->sock_fd);
    RT_ASSERT(res == 0);

    thiz->sock_fd = -1;

    LOG_D("tcpclient%d socket deinit,socket close succeed\n",thiz->tcpclient_number);

    return 0;
}

/**
 * @brief tcp客户端的管道初始化
 * @author shijiabao
 * @date 2021.08.20
 * @param rt_tcpclient_t：tcp客户端结构体
 * @return 0：成功
 *        -1：失败
 */
static rt_int32_t pipe_init(rt_tcpclient_t *thiz)
{
    char dev_name[32];
    static int pipeno = 0;
    rt_pipe_t *pipe = RT_NULL;

    if (thiz == RT_NULL)
    {
        LOG_D("tcpclient%d pipe init, param is NULL\n",thiz->tcpclient_number);
        return -1;
    }

    snprintf(thiz->pipe_name, sizeof(thiz->pipe_name), "pipe%d", pipeno++);

    pipe = rt_pipe_create(thiz->pipe_name, PIPE_BUFSZ);
    if (pipe == RT_NULL)
    {
        LOG_D("tcpclient%d pipe create, pipe create failed\n",thiz->tcpclient_number);
        return -1;
    }

    snprintf(dev_name, sizeof(dev_name), "/dev/%s", thiz->pipe_name);
    thiz->pipe_read_fd = open(dev_name, O_RDONLY, 0);
    if (thiz->pipe_read_fd < 0)
        goto fail_read;

    thiz->pipe_write_fd = open(dev_name, O_WRONLY, 0);
    if (thiz->pipe_write_fd < 0)
        goto fail_write;

    LOG_D("tcpclient%d pipe init, pipe init succeed\n",thiz->tcpclient_number);
    return 0;

fail_write:
    close(thiz->pipe_read_fd);
fail_read:
    return -1;
}

/**
 * @brief tcp客户端的管道摧毁
 * @author shijiabao
 * @date 2021.08.20
 * @param rt_tcpclient_t：tcp客户端结构体
 * @return 0：成功
 *        -1：失败
 */
static rt_int32_t pipe_deinit(rt_tcpclient_t *thiz)
{
    int res = 0;

    if (thiz == RT_NULL)
    {
        LOG_D("tcpclient%d pipe deinit, param is NULL, pipe deinit failed\n", thiz->tcpclient_number);
        return -1;
    }

    res = close(thiz->pipe_read_fd);
    RT_ASSERT(res == 0);
    thiz->pipe_read_fd = -1;

    res = close(thiz->pipe_write_fd);
    RT_ASSERT(res == 0);
    thiz->pipe_write_fd = -1;

    rt_pipe_delete(thiz->pipe_name);

    LOG_D("tcpclient%d pipe deinit, pipe close succeed\n", thiz->tcpclient_number);
    return 0;
}

/**
 * @brief select处理函数，通过检查pipe和socket来进行收发数据
 * @author shijiabao
 * @date 2021.08.20
 * @param thiz：客户端结构体
 *        pipe_buff：管道地址
 *        sock_buff：套接字地址
 * @return
 */
static void select_handle(rt_tcpclient_t *thiz, char *pipe_buff, char *sock_buff)
{
    fd_set fds;

    rt_int32_t max_fd = 0, res = 0;
    max_fd = MAX_VAL(thiz->sock_fd, thiz->pipe_read_fd) + 1;

    /* 清空可读事件描述符列表 */
    FD_ZERO(&fds);


//    if(thiz->tcpclient_number == 1)
//    {
//        /*为1的状态说明已经连接上*/
//        device_parm.status.tt_server1_connect_flag = 1;
//    }
//    else if(thiz->tcpclient_number == 2)
//    {
//        /*为1的状态说明已经连接上*/
//        device_parm.status.tt_server2_connect_flag = 1;
//    }
//    else if(thiz->tcpclient_number == 3)
//    {
//        /*为1的状态说明已经连接上*/
//        device_parm.status.private_server_connect_flag = 1;
//    }
//    else
//    {
//        ;
//    }
    while (1)
    {
        /* 将需要监听可读事件的描述符加入列表 */
        FD_SET(thiz->sock_fd, &fds);
        FD_SET(thiz->pipe_read_fd, &fds);

        /* 等待设定的网络描述符有事件发生 */
        res = select(max_fd, &fds, RT_NULL, RT_NULL, RT_NULL);

        /* select 返回错误及超时处理exit */
        EXCEPTION_HANDLE(res, "select handle", "error", "timeout", thiz->tcpclient_number);

         /* 查看 sock 描述符上有没有发生可读事件 socket is ready */
        if (FD_ISSET(thiz->sock_fd, &fds))
        {
            /* 从 sock 连接中接收最大BUFSZ - 1字节数据 */
            res = recv(thiz->sock_fd, sock_buff, BUFF_SIZE, 0);

            /* recv 返回异常 exit */
            EXCEPTION_HANDLE(res, "socket recv handle", "error", "TCP disconnected", thiz->tcpclient_number);

            /* 有接收到数据，把末端清零 */
            sock_buff[res] = '\0';

            /* 通过回调函数的方式，数据发给对应 thread */
            RX_CB_HANDLE(sock_buff, res, thiz->tcpclient_number);

            /* 如果接收的是exit，关闭这个连接 */
            EXIT_HANDLE(sock_buff);
        }

        /* 查看 pipe 描述符上有没有发生可读事件 */
        if (FD_ISSET(thiz->pipe_read_fd, &fds))
        {
            /* 从 pipe 连接中接收最大BUFSZ - 1字节数据 */
            res = read(thiz->pipe_read_fd, pipe_buff, BUFF_SIZE);

            /* recv 返回异常 */
            EXCEPTION_HANDLE(res, "pipe recv handle", "error", RT_NULL, thiz->tcpclient_number);

            /* 有接收到数据，把末端清零 */
            pipe_buff[res] = '\0';

            /* 读取 pipe 的数据，转发给 server */
//            send(thiz->sock_fd, pipe_buff, res, 0);
            if(send(thiz->sock_fd, pipe_buff, res, 0)==-1)
                goto exit;

            /* recv 返回异常 */
            EXCEPTION_HANDLE(res, "socket write handle", "error", "warning", thiz->tcpclient_number);

            /* 如果接收的是 exit，关闭这个连接 */
            EXIT_HANDLE(pipe_buff);
        }
    }
exit:
//    rt_tc_test_deinit(thiz);    //增添的
if(thiz->tcpclient_number==1)
    device_parm.status.tt_server1_connect_flag = 0;
if(thiz->tcpclient_number==2)
    device_parm.status.tt_server2_connect_flag = 0;
if(thiz->tcpclient_number==3)
    device_parm.status.private_server_connect_flag = 0;
    tcpclient_destory(thiz);
    free(pipe_buff);  //打算直接加到摧毁函数里面
    free(sock_buff);

}

/**
 * @brief tcp客户端线程初始化
 * @author shijiabao
 * @date 2021.08.20
 * @param
 * @return
 */
static rt_int32_t tcpclient_thread_init(rt_tcpclient_t *thiz)
{
    rt_thread_t tcpclient_tid = RT_NULL;

    if(thiz->tcpclient_number == 1)
        tcpclient_tid = rt_thread_create("tcpc1", tcpclient_thread_entry, thiz, 1500, 10, 10);
    if(thiz->tcpclient_number == 2)
        tcpclient_tid = rt_thread_create("tcpc2", tcpclient_thread_entry, thiz, 1500, 10, 10);
    if(thiz->tcpclient_number == 3)
        tcpclient_tid = rt_thread_create("tcpc3", tcpclient_thread_entry, thiz, 2048, 10, 10);        //调整了堆栈大小，否则升级会失败

    if (tcpclient_tid == RT_NULL)
    {
        LOG_D("tcpclient%d tcpclient thread, thread create failed\n",thiz->tcpclient_number);
        return -1;
    }

    rt_thread_startup(tcpclient_tid);

    LOG_D("tcpclient%d tcpclient thread, thread init succeed\n",thiz->tcpclient_number);
    return 0;
}

/**
 * @brief tcp客户端线程
 * @author shijiabao
 * @date 2021.08.20
 * @param
 * @return
 */
static void tcpclient_thread_entry(void *param)
{
    rt_tcpclient_t *temp = param;
    char *pipe_buff = RT_NULL, *sock_buff = RT_NULL;

    pipe_buff = malloc(BUFF_SIZE);
    if (pipe_buff == RT_NULL)
    {
        LOG_D("tcpclient%d thread entry, malloc error\n",temp->tcpclient_number);
        LOG_D("tcpclient%d thread entry, exit\n",temp->tcpclient_number);
        return;
    }

    sock_buff = malloc(BUFF_SIZE);
    if (sock_buff == RT_NULL)
    {
        free(pipe_buff);
        LOG_D("tcpclient%d thread entry, malloc error\n",temp->tcpclient_number);
        LOG_D("tcpclient%d thread entry, exit\n",temp->tcpclient_number);
        return;
    }
        if(temp->tcpclient_number == 1)
        {
            /*为1的状态说明已经连接上*/
            device_parm.status.tt_server1_connect_flag = 1;
        }
        else if(temp->tcpclient_number == 2)
        {
            /*为1的状态说明已经连接上*/
            device_parm.status.tt_server2_connect_flag = 1;
        }
        else if(temp->tcpclient_number == 3)
        {
            /*为1的状态说明已经连接上*/
            device_parm.status.private_server_connect_flag = 1;
        }
        else
        {
            ;
        }

    memset(sock_buff, 0, BUFF_SIZE);
    memset(pipe_buff, 0, BUFF_SIZE);

    select_handle(temp, pipe_buff, sock_buff);
}

rt_tcpclient_t *rt_tcpclient_start(uint8_t tcpclient_number,const char *hostname, rt_uint32_t port)
{
    rt_tcpclient_t *tcpclient = RT_NULL;

    tcpclient = tcpclient_create(tcpclient_number);
    if (tcpclient == RT_NULL)
        return RT_NULL;

    if(tcpclient_number == 1)
    {
        tcpclient1 = tcpclient;
    }else if(tcpclient_number == 2)
    {
        tcpclient2 = tcpclient;
    }else if(tcpclient_number == 3)
    {
        tcpclient3 = tcpclient;
    }else {
        ;
    }
    /* 注册接收回调函数 */
//    rt_tcpclient_attach_rx_cb(tcpclient, rt_tc_rx_cb);

    if (pipe_init(tcpclient) != 0)
        goto quit;

    if (socket_init(tcpclient, hostname, port) != 0)
        goto quit;

    if (tcpclient_thread_init(tcpclient) != 0)
       goto quit;

    LOG_D("tcpclient%d start, tcpclient start succeed\n",tcpclient->tcpclient_number);
    /* 注册接收回调函数 */
    rt_tcpclient_attach_rx_cb(tcpclient, rt_tc_rx_cb);
    return tcpclient;

quit:
    rt_tc_test_deinit(tcpclient);
    LOG_D("client destory");
    return RT_NULL;
}

void rt_tcpclient_close(rt_tcpclient_t *thiz)
{
    if (thiz == RT_NULL)
    {
        LOG_D("tcpclient%d deinit, param is NULL, tcpclient deinit failed\n", thiz->tcpclient_number);
        return;
    }

    if (socket_deinit(thiz) != 0)
        return;

    if (pipe_deinit(thiz) != 0)
        return;

    if (tcpclient_destory(thiz) != 0)
        return;

    LOG_D("tcpclient%d tcpclient deinit, tcpclient deinit succeed\n",thiz->tcpclient_number);
}

rt_int32_t rt_tcpclient_send(rt_tcpclient_t *thiz, const void *buff, rt_size_t len)
{
    rt_size_t bytes = 0;

    if (thiz == RT_NULL)
    {
        LOG_D("tcpclient%d send, param is NULL\n", thiz->tcpclient_number);
        return -1;
    }

    if (buff == RT_NULL)
    {
        LOG_D("tcpclient%d send, buff is NULL\n",thiz->tcpclient_number);
        return -1;
    }
    bytes = write(thiz->pipe_write_fd, buff, len);
    return bytes;
}

rt_int32_t rt_tcpclient_send1(const void *buff, rt_size_t len)
{
    return rt_tcpclient_send(tcpclient1,buff,len);
}

rt_int32_t rt_tcpclient_send2(const void *buff, rt_size_t len)
{
    return rt_tcpclient_send(tcpclient2,buff,len);
}

rt_int32_t rt_tcpclient_send3(const void *buff, rt_size_t len)
{
    return rt_tcpclient_send(tcpclient3,buff,len);
}

rt_int32_t rt_tcpclient_attach_rx_cb(rt_tcpclient_t *thiz, rx_cb_t cb)
{
    if (thiz == RT_NULL)
    {
        LOG_D("%d callback attach, param is NULL\n",thiz->tcpclient_number);
        return -1;
    }

    thiz->rx = cb;
    LOG_D("%d callback attach, attach succeed\n",thiz->tcpclient_number);
    printf("device_parm.status.tt_server1_connect_flag: %d\n",device_parm.status.tt_server1_connect_flag);
    printf("device_parm.status.tt_server2_connect_flag: %d\n",device_parm.status.tt_server2_connect_flag);
    printf("device_parm.status.private_server_connect_flag: %d\n",device_parm.status.private_server_connect_flag);
    printf("device_parm.status.mqtt_server_connect_flag: %d\n",device_parm.status.mqtt_server_connect_flag);
    printf("device_parm.status.network_init_flag: %d\n",device_parm.status.network_init_flag);
    return 0;

}

static void rt_tc_rx_cb(void *buff, rt_size_t len,uint8_t client_number)
{
    char *recv = RT_NULL;

    recv = malloc(len + 1);
    if (recv == RT_NULL)
        return;

    memcpy(recv, buff, len);
    *(recv + len) = '\0';

    LOG_D("tc_rx_cb, recv data(string)(client%d): %s\n", client_number, recv);
    rt_kprintf("tc_rx_cb, recv data(hex)(client %d):", client_number);
    for(int i =0;i<len;i++)
    {
        rt_kprintf("%x ", recv[i]);
    }
    rt_kprintf("\n");
    LOG_D("tc_rx_cb, recv len: %d\n", strlen(recv));

        if(client_number == 1 || client_number == 2)
        {
            rs485_uart_write(recv,len);
            rs232_uart_write(recv,len);
        }
//        if(buff)
        if(client_number == 3)
        {
            private_data_parse(recv, len);
        }
    free(recv);
}

static void rt_tc_test_deinit(rt_tcpclient_t *thiz)
{
    rt_tcpclient_close(thiz);
}

int network_client_start(uint8_t client_number,const char *hostname, rt_uint32_t port)
{
    rt_tcpclient_t *handle = RT_NULL;

    /* when connect_flag is 0,network client started but not connect */
    if(client_number == 1)
    {
        device_parm.status.tt_server1_connect_flag = 0;
    }
    else if(client_number == 2)
    {
        device_parm.status.tt_server2_connect_flag = 0;
    }
    else if(client_number == 3)
    {
        device_parm.status.private_server_connect_flag = 0;
    }
    else
    {
        LOG_D("network client start，client number %d error.", client_number);
        return -1;
    }

    /* 服务器的 ip 地址 & 服务器监听的端口号 */
    handle = rt_tcpclient_start(client_number,hostname, port);
    if (handle == RT_NULL)
    {
        LOG_D("network client %d thread, param is NULL, exit\n", client_number);

        /* tcp client started failed,connect flag is 0 */
       if(client_number == 1)
       {
          device_parm.status.tt_server1_connect_flag = 0;
       }
       else if(client_number == 2)
       {
          device_parm.status.tt_server2_connect_flag = 0;
       }
       else if(client_number == 3)
       {
           device_parm.status.private_server_connect_flag = 0;
       }
       else
       {
           LOG_D("network client start error，client number %d error.", client_number);
       }
       return -1;
    }
    return 0;
}

void close_all_socket(void)
{
    mqtt_status_send_flag = 0;
    if(device_parm.status.tt_server1_connect_flag == 1)
    {
        printf("------------------close tcp connect 1---------------\n");
        closesocket(tcpclient1->sock_fd);
        device_parm.status.tt_server1_connect_flag = 0;
    }
    strcpy(device_parm.configure.data_center1_switch, "0");
    rt_thread_mdelay(2000);

    if(device_parm.status.tt_server2_connect_flag == 1)
    {
        printf("------------------close tcp connect 2---------------\n");
        closesocket(tcpclient2->sock_fd);
        device_parm.status.tt_server2_connect_flag = 0;
    }
    strcpy(device_parm.configure.data_center2_switch, "0");
    rt_thread_mdelay(2000);

    if(device_parm.status.private_server_connect_flag ==1)
    {
        printf("------------------close tcp connect 3---------------\n");
        closesocket(tcpclient3->sock_fd);
        device_parm.status.private_server_connect_flag = 0;
    }
    strcpy(device_parm.configure.data_transmission_mode, "0");
    rt_thread_mdelay(2000);
}

static int connect_status_print(int argc, char **argv)
{
    if (argc != 1)
    {
        rt_kprintf("connect_status_print \n");
    }

    printf("device_parm.status.tt_server1_connect_flag: %d\n",device_parm.status.tt_server1_connect_flag);
    printf("device_parm.status.tt_server2_connect_flag: %d\n",device_parm.status.tt_server2_connect_flag);
    printf("device_parm.status.private_server_connect_flag: %d\n",device_parm.status.private_server_connect_flag);
    printf("device_parm.status.mqtt_server_connect_flag: %d\n",device_parm.status.mqtt_server_connect_flag);
    printf("device_parm.status.network_init_flag: %d\n",device_parm.status.network_init_flag);
    return 0;
}

MSH_CMD_EXPORT(connect_status_print, connect status print);
